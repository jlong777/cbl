/* cb_uncompress.c                               http://cbl.sourceforge.net
 *
 * uncompress things compressed with cb_compress
 * see original man page at the bottom. This code is the generic version
 * with provision for 32 and 64 bit long ints.
 *
 * Copyright (C) 2003 University of Alaska Fairbanks
 * Arctic Region Supercomputing Center (ARSC)
 * http://www.arsc.edu
 * 
 *   This library is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Lesser General Public License as
 *   published by the Free Software Foundation; either version 2.1 of the
 *   License, or (at your option) any later version.
 *  
 *   This library is distributed in the hope that it will be useful, but
 *   WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *   Lesser General Public License for more details.
 *  
 *   You should have received a copy of the GNU Lesser General Public
 *   License along with this library; if not, write to the
 *   Free Software Foundation, Inc.
 *   59 Temple Place, Suite 330
 *   Boston, MA  02111-1307 USA
 *
 * $Id: cb_uncompress.c,v 1.6 2005/01/13 22:51:01 jlong777 Exp $
 */

#include "cb_macro.h"
#include <stdio.h>

void cb_uncompress(long *dbc, long *db, long dblen, long mode)
{
  long i, length;
  
  unsigned long bit4[16];
  
  bit4[0x00] = 0x5A; /* Z, can be E, F, I, J, L, O, P, Q, Z */
  bit4[0x01] = 0x54; /* T, can be T, U */
  bit4[0x02] = 0x47; /* G */
  bit4[0x03] = 0x4B; /* K */
  bit4[0x04] = 0x43; /* C */
  bit4[0x05] = 0x59; /* Y */
  bit4[0x06] = 0x53; /* S */
  bit4[0x07] = 0x42; /* B */
  bit4[0x08] = 0x41; /* A */
  bit4[0x09] = 0x57; /* W */
  bit4[0x0A] = 0x52; /* R */
  bit4[0x0B] = 0x44; /* D */
  bit4[0x0C] = 0x4D; /* M */
  bit4[0x0D] = 0x48; /* H */
  bit4[0x0E] = 0x56; /* V */
  bit4[0x0F] = 0x4E; /* N, can be N, X */
  

#ifdef LONG32
  length = (dblen+3)/4;
  switch (mode)
  {
#ifdef B_ENDIAN
    case 2:
      for(i=0; i<length-4; i+=4)
      {
	db[i]   = (((0xC0000000 & dbc[i/4]) ^ 0x80000000)? /* is it a T? */
	          (((unsigned long)(0xC0000000 & dbc[i/4]) >>  5) | 0x41000000):
	            (0x54000000))|
		  (((0x30000000 & dbc[i/4]) ^ 0x20000000)? /* is it a T? */
		  (((unsigned long)(0x30000000 & dbc[i/4]) >> 11) | 0x00410000):
	            (0x00540000))|
		  (((0x0C000000 & dbc[i/4]) ^ 0x08000000)? /* is it a T? */
		  (((unsigned long)(0x0C000000 & dbc[i/4]) >> 17) | 0x00004100):
	            (0x00005400))|
		  (((0x03000000 & dbc[i/4]) ^ 0x02000000)? /* is it a T? */
		  (((unsigned long)(0x03000000 & dbc[i/4]) >> 23) | 0x00000041):
	            (0x00000054));
		       
	db[i+1] = (((0x00C00000 & dbc[i/4]) ^ 0x00800000)?
	          (((unsigned long)(0x00C00000 & dbc[i/4]) <<  3) | 0x41000000):
	            (0x54000000))|
		  (((0x00300000 & dbc[i/4]) ^ 0x00200000)?
		  (((unsigned long)(0x00300000 & dbc[i/4]) >>  3) | 0x00410000):
	            (0x00540000))|
		  (((0x000C0000 & dbc[i/4]) ^ 0x00080000)?
		  (((unsigned long)(0x000C0000 & dbc[i/4]) >>  9) | 0x00004100):
	            (0x00005400))|
		  (((0x00030000 & dbc[i/4]) ^ 0x00020000)?
		  (((unsigned long)(0x00030000 & dbc[i/4]) >> 15) | 0x00000041):
	            (0x00000054));
		       
	db[i+2] = (((0x0000C000 & dbc[i/4]) ^ 0x00008000)?
	          (((unsigned long)(0x0000C000 & dbc[i/4]) << 11) | 0x41000000):
	            (0x54000000))|
		  (((0x00003000 & dbc[i/4]) ^ 0x00002000)?
		  (((unsigned long)(0x00003000 & dbc[i/4]) <<  5) | 0x00410000):
	            (0x00540000))|
		  (((0x00000C00 & dbc[i/4]) ^ 0x00000800)?
		  (((unsigned long)(0x00000C00 & dbc[i/4]) >>  1) | 0x00004100):
	            (0x00005400))|
		  (((0x00000300 & dbc[i/4]) ^ 0x00000200)?
		  (((unsigned long)(0x00000300 & dbc[i/4]) >>  7) | 0x00000041):
	            (0x00000054));
		       
	db[i+3] = (((0x000000C0 & dbc[i/4]) ^ 0x00000080)?
	          (((0x000000C0 & dbc[i/4]) << 19) | 0x41000000):
	            (0x54000000))|
		  (((0x00000030 & dbc[i/4]) ^ 0x00000020)?
		  (((0x00000030 & dbc[i/4]) << 13) | 0x00410000):
	            (0x00540000))|
		  (((0x0000000C & dbc[i/4]) ^ 0x00000008)?
		  (((0x0000000C & dbc[i/4]) <<  7) | 0x00004100):
	            (0x00005400))|
		  (((0x00000003 & dbc[i/4]) ^ 0x00000002)?
		  (((0x00000003 & dbc[i/4]) <<  1) | 0x00000041):
	            (0x00000054));
      }
      db[i]   = ((4*i   >= dblen)? 0x00 :          /* out of chars? */
	        (((0xC0000000 & dbc[i/4]) ^ 0x80000000)? /* is it a T? */
		(((unsigned long)(0xC0000000 & dbc[i/4]) >>  5) | 0x41000000):
	          (0x54000000)))|
                ((4*i+1 >= dblen)? 0x00 :        /* out of chars? */
		(((0x30000000 & dbc[i/4]) ^ 0x20000000)? /* is it a T? */
		(((unsigned long)(0x30000000 & dbc[i/4]) >> 11) | 0x00410000):
	          (0x00540000)))|
		((4*i+2 >= dblen)? 0x00 :        /* out of chars? */
		(((0x0C000000 & dbc[i/4]) ^ 0x08000000)? /* is it a T? */
		(((unsigned long)(0x0C000000 & dbc[i/4]) >> 17) | 0x00004100):
	          (0x00005400)))|
		((4*i+3 >= dblen)? 0x00 :        /* out of chars? */
		(((0x03000000 & dbc[i/4]) ^ 0x02000000)? /* is it a T? */
		(((unsigned long)(0x03000000 & dbc[i/4]) >> 23) | 0x00000041):
	          (0x00000054)));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */

      db[i+1] = ((4*i+4 >= dblen)?  0x00 :
	        (((0x00C00000 & dbc[i/4]) ^ 0x00800000)?
		(((unsigned long)(0x00C00000 & dbc[i/4]) <<  3) | 0x41000000):
	          (0x54000000)))|
		((4*i+5 >= dblen)?  0x00 :
		(((0x00300000 & dbc[i/4]) ^ 0x00200000)?
		(((unsigned long)(0x00300000 & dbc[i/4]) >>  3) | 0x00410000):
	          (0x00540000)))|
		((4*i+6 >= dblen)?  0x00 :
		(((0x000C0000 & dbc[i/4]) ^ 0x00080000)?
		(((unsigned long)(0x000C0000 & dbc[i/4]) >>  9) | 0x00004100):
	          (0x00005400)))|
		((4*i+7 >= dblen)?  0x00 :
		(((0x00030000 & dbc[i/4]) ^ 0x00020000)?
		(((unsigned long)(0x00030000 & dbc[i/4]) >> 15) | 0x00000041):
	          (0x00000054)));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
		 
      db[i+2] = ((4*i+8 >= dblen)?  0x00 :
	        (((0x0000C000 & dbc[i/4]) ^ 0x00008000)?
		(((unsigned long)(0x0000C000 & dbc[i/4]) << 11) | 0x41000000):
	          (0x54000000)))|
		((4*i+9 >= dblen)?  0x00 :
		(((0x00003000 & dbc[i/4]) ^ 0x00002000)?
		(((unsigned long)(0x00003000 & dbc[i/4]) <<  5) | 0x00410000):
	          (0x00540000)))|
		((4*i+10 >= dblen)?  0x00 :
		(((0x00000C00 & dbc[i/4]) ^ 0x00000800)?
		(((unsigned long)(0x00000C00 & dbc[i/4]) >>  1) | 0x00004100):
	          (0x00005400)))|
		((4*i+11 >= dblen)?  0x00 :
		(((0x00000300 & dbc[i/4]) ^ 0x00000200)?
		(((unsigned long)(0x00000300 & dbc[i/4]) >>  7) | 0x00000041):
	          (0x00000054)));

      if(i+4 > length) break; /* i.e. i+3 > length-1 ? */
		 
      db[i+3] = ((4*i+12 >= dblen)?  0x00 :
	        (((0x000000C0 & dbc[i/4]) ^ 0x00000080)?
		(((0x000000C0 & dbc[i/4]) << 19) | 0x41000000):
	          (0x54000000)))|
		((4*i+13 >= dblen)?  0x00 :
		(((0x00000030 & dbc[i/4]) ^ 0x00000020)?
		(((0x00000030 & dbc[i/4]) << 13) | 0x00410000):
	          (0x00540000)))|
		((4*i+14 >= dblen)?  0x00 :
		(((0x0000000C & dbc[i/4]) ^ 0x00000008)?
		(((0x0000000C & dbc[i/4]) <<  7) | 0x00004100):
	          (0x00005400)))|
		((4*i+15 >= dblen)?  0x00 :
		(((0x00000003 & dbc[i/4]) ^ 0x00000002)?
		(((0x00000003 & dbc[i/4]) <<  1) | 0x00000041):
	          (0x00000054)));
      break;
	
    case 4:
      for(i=0; i<length-2; i+=2)
      {
        db[i]   = (bit4[(unsigned long)(0xF0000000 & dbc[i/2]) >> 28] << 24) |
	          (bit4[(unsigned long)(0x0F000000 & dbc[i/2]) >> 24] << 16) |
	          (bit4[(unsigned long)(0x00F00000 & dbc[i/2]) >> 20] <<  8) |
	          (bit4[(unsigned long)(0x000F0000 & dbc[i/2]) >> 16]);
	db[i+1] = (bit4[(unsigned long)(0x0000F000 & dbc[i/2]) >> 12] << 24) |
	          (bit4[(unsigned long)(0x00000F00 & dbc[i/2]) >>  8] << 16) |
	          (bit4[(unsigned long)(0x000000F0 & dbc[i/2]) >>  4] <<  8) |
	          (bit4[                0x0000000F & dbc[i/2]]);
      }
      db[i]   = ((4*i   >= dblen)? 0x00 :       /* out of chars? */
                (bit4[(unsigned long)(0xF0000000 & dbc[i/2]) >> 28] << 24)) |
		((4*i+1 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x0F000000 & dbc[i/2]) >> 24] << 16)) |
		((4*i+2 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x00F00000 & dbc[i/2]) >> 20] <<  8)) |
		((4*i+3 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x000F0000 & dbc[i/2]) >> 16]));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		 
      db[i+1] = ((4*i+4 >= dblen)? 0x00 :           /* out of chars? */
                (bit4[(unsigned long)(0x0000F000 & dbc[i/2]) >> 12] << 24)) |
		((4*i+5 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x00000F00 & dbc[i/2]) >>  8] << 16)) |
		((4*i+6 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x000000F0 & dbc[i/2]) >>  4] <<  8)) |
		((4*i+7 >= dblen)? 0x00 :
	        (bit4[                0x0000000F & dbc[i/2]]));
      break;
	
    case 5:
      for(i=0; i<length-3; i+=3)
      {
        db[i]   = (((unsigned long)(0x3E000000 & dbc[(2*i)/3])   >>  1)  |
	           ((unsigned long)(0x01F00000 & dbc[(2*i)/3])   >>  4)  |
	           ((unsigned long)(0x000F8000 & dbc[(2*i)/3])   >>  7)  |
	           ((unsigned long)(0x00007C00 & dbc[(2*i)/3])   >> 10)) | 0x40404040;
		   
	db[i+1] = (((unsigned long)(0x000003E0 & dbc[(2*i)/3])   << 19)  |
	           ((unsigned long)(0x0000001F & dbc[(2*i)/3])   << 16)  |
	           ((unsigned long)(0x3E000000 & dbc[(2*i)/3+1]) >> 17)  |
		   ((unsigned long)(0x01F00000 & dbc[(2*i)/3+1]) >> 20)) | 0x40404040;
	
	db[i+2] = (((unsigned long)(0x000F8000 & dbc[(2*i)/3+1]) <<  9)  |
	           ((unsigned long)(0x00007C00 & dbc[(2*i)/3+1]) <<  6)  |
		   ((unsigned long)(0x000003E0 & dbc[(2*i)/3+1]) <<  3)  |
		    (unsigned long)(0x0000001F & dbc[(2*i)/3+1])       ) | 0x40404040;
      }
      db[i]   = ((4*i   >= dblen)? 0x00 :          /* out of chars? */
                (( (unsigned long)(0x3E000000 & dbc[(2*i)/3])   >>  1) | 0x40000000)) |
		((4*i+1 >= dblen)? 0x00 :
	        (( (unsigned long)(0x01F00000 & dbc[(2*i)/3])   >>  4) | 0x00400000)) |
		((4*i+2 >= dblen)? 0x00 :
	        (( (unsigned long)(0x000F8000 & dbc[(2*i)/3])   >>  7) | 0x00004000)) |
		((4*i+3 >= dblen)? 0x00 :
	        (( (unsigned long)(0x00007C00 & dbc[(2*i)/3])   >> 10) | 0x00000040));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		   
      db[i+1] = ((4*i+4 >= dblen)? 0x00 :
                (( (unsigned long)(0x000003E0 & dbc[(2*i)/3])   << 19) | 0x40000000)) |
		((4*i+5 >= dblen)? 0x00 :
	        (( (unsigned long)(0x0000001F & dbc[(2*i)/3])   << 16) | 0x00400000)) |
		((4*i+6 >= dblen)? 0x00 :
	        (( (unsigned long)(0x3E000000 & dbc[(2*i)/3+1]) >> 17) | 0x00004000)) |
		((4*i+7 >= dblen)? 0x00 :
		(( (unsigned long)(0x01F00000 & dbc[(2*i)/3+1]) >> 20) | 0x00000040));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
	
      db[i+2] = ((4*i+8 >= dblen)? 0x00 :
                (( (unsigned long)(0x000F8000 & dbc[(2*i)/3+1]) <<  9) | 0x40000000)) |
		((4*i+9 >= dblen)? 0x00 :
	        (( (unsigned long)(0x00007C00 & dbc[(2*i)/3+1]) <<  6) | 0x00400000)) |
		((4*i+10>= dblen)? 0x00 :
		(( (unsigned long)(0x000003E0 & dbc[(2*i)/3+1]) <<  3) | 0x00004000)) |
		((4*i+11>= dblen)? 0x00 :
		(                 (0x0000001F & dbc[(2*i)/3+1])         | 0x00000040));

      break;
#endif /* big-endian */
#ifdef L_ENDIAN
    case 2:
      for(i=0; i<length-4; i+=4)
      {
	db[i]   = (((0x00000003 & dbc[i/4]) ^ 0x00000002)? /* is it a T? */
	          (((unsigned long)(0x00000003 & dbc[i/4]) <<  1) | 0x00000041):
	            (0x00000054))|
		  (((0x0000000C & dbc[i/4]) ^ 0x00000008)? /* is it a T? */
		  (((unsigned long)(0x0000000C & dbc[i/4]) <<  7) | 0x00004100):
	            (0x00005400))|
		  (((0x00000030 & dbc[i/4]) ^ 0x00000020)? /* is it a T? */
		  (((unsigned long)(0x00000030 & dbc[i/4]) << 13) | 0x00410000):
	            (0x00540000))|
		  (((0x000000C0 & dbc[i/4]) ^ 0x00000080)? /* is it a T? */
		  (((unsigned long)(0x000000C0 & dbc[i/4]) << 19) | 0x41000000):
	            (0x54000000));
		       
	db[i+1] = (((0x00000300 & dbc[i/4]) ^ 0x00000200)?
	          (((unsigned long)(0x00000300 & dbc[i/4]) >>  7) | 0x00000041):
	            (0x00000054))|
		  (((0x00000C00 & dbc[i/4]) ^ 0x00000800)?
		  (((unsigned long)(0x00000C00 & dbc[i/4]) >>  1) | 0x00004100):
	            (0x00005400))|
		  (((0x00003000 & dbc[i/4]) ^ 0x00002000)?
		  (((unsigned long)(0x00003000 & dbc[i/4]) <<  5) | 0x00410000):
	            (0x00540000))|
		  (((0x0000C000 & dbc[i/4]) ^ 0x00008000)?
		  (((unsigned long)(0x0000C000 & dbc[i/4]) << 11) | 0x41000000):
	            (0x54000000));
		       
	db[i+2] = (((0x00030000 & dbc[i/4]) ^ 0x00020000)?
	          (((unsigned long)(0x00030000 & dbc[i/4]) >> 15) | 0x00000041):
	            (0x00000054))|
		  (((0x000C0000 & dbc[i/4]) ^ 0x00080000)?
		  (((unsigned long)(0x000C0000 & dbc[i/4]) >>  9) | 0x00004100):
	            (0x00005400))|
		  (((0x00300000 & dbc[i/4]) ^ 0x00200000)?
		  (((unsigned long)(0x00300000 & dbc[i/4]) >>  3) | 0x00410000):
	            (0x00540000))|
		  (((0x00C00000 & dbc[i/4]) ^ 0x00800000)?
		  (((unsigned long)(0x00C00000 & dbc[i/4]) <<  3) | 0x41000000):
	            (0x54000000));
		       
	db[i+3] = (((0x03000000 & dbc[i/4]) ^ 0x02000000)?
	          (((unsigned long)(0x03000000 & dbc[i/4]) >> 23) | 0x00000041):
	            (0x00000054))|
		  (((0x0C000000 & dbc[i/4]) ^ 0x08000000)?
		  (((unsigned long)(0x0C000000 & dbc[i/4]) >> 17) | 0x00004100):
	            (0x00005400))|
		  (((0x30000000 & dbc[i/4]) ^ 0x20000000)?
		  (((unsigned long)(0x30000000 & dbc[i/4]) >> 11) | 0x00410000):
	            (0x00540000))|
		  (((0xC0000000 & dbc[i/4]) ^ 0x80000000)?
		  (((unsigned long)(0xC0000000 & dbc[i/4]) >>  5) | 0x41000000):
	            (0x54000000));
      }
      db[i]   = ((4*i >= dblen)? 0x00 :          /* out of chars? */
	        (((0x00000003 & dbc[i/4]) ^ 0x00000002)? /* is it a T? */
		(((unsigned long)(0x00000003 & dbc[i/4]) <<  1) | 0x00000041):
	          (0x00000054)))|
                ((4*i+1 >= dblen)? 0x00 :        /* out of chars? */
		(((0x0000000C & dbc[i/4]) ^ 0x00000008)? /* is it a T? */
		(((unsigned long)(0x0000000C & dbc[i/4]) <<  7) | 0x00004100):
	          (0x00005400)))|
		((4*i+2 >= dblen)? 0x00 :        /* out of chars? */
		(((0x00000030 & dbc[i/4]) ^ 0x00000020)? /* is it a T? */
		(((unsigned long)(0x00000030 & dbc[i/4]) << 13) | 0x00410000):
	          (0x00540000)))|
		((4*i+3 >= dblen)? 0x00 :        /* out of chars? */
		(((0x000000C0 & dbc[i/4]) ^ 0x00000080)? /* is it a T? */
		(((unsigned long)(0x000000C0 & dbc[i/4]) << 19) | 0x41000000):
	          (0x54000000)));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		 
      db[i+1] = ((4*i+4 >= dblen)?  0x00 :
	        (((0x00000300 & dbc[i/4]) ^ 0x00000200)?
		(((unsigned long)(0x00000300 & dbc[i/4]) >>  7) | 0x00000041):
	          (0x00000054)))|
		((4*i+5 >= dblen)?  0x00 :
		(((0x00000C00 & dbc[i/4]) ^ 0x00000800)?
		(((unsigned long)(0x00000C00 & dbc[i/4]) >>  1) | 0x00004100):
	          (0x00005400)))|
		((4*i+6 >= dblen)?  0x00 :
		(((0x00003000 & dbc[i/4]) ^ 0x00002000)?
		(((unsigned long)(0x00003000 & dbc[i/4]) <<  5) | 0x00410000):
	          (0x00540000)))|
		((4*i+7 >= dblen)?  0x00 :
		(((0x0000C000 & dbc[i/4]) ^ 0x00008000)?
		(((unsigned long)(0x0000C000 & dbc[i/4]) << 11) | 0x41000000):
	          (0x54000000)));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
		 
      db[i+2] = ((4*i+8 >= dblen)?  0x00 :
	        (((0x00030000 & dbc[i/4]) ^ 0x00020000)?
		(((unsigned long)(0x00030000 & dbc[i/4]) >> 15) | 0x00000041):
	          (0x00000054)))|
		((4*i+9 >= dblen)?  0x00 :
		(((0x000C0000 & dbc[i/4]) ^ 0x00080000)?
		(((unsigned long)(0x000C0000 & dbc[i/4]) >>  9) | 0x00004100):
	          (0x00005400)))|
		((4*i+10 >= dblen)?  0x00 :
		(((0x00300000 & dbc[i/4]) ^ 0x00200000)?
		(((unsigned long)(0x00300000 & dbc[i/4]) >>  3) | 0x00410000):
	          (0x00540000)))|
		((4*i+11 >= dblen)?  0x00 :
		(((0x00C00000 & dbc[i/4]) ^ 0x00800000)?
		(((unsigned long)(0x00C00000 & dbc[i/4]) <<  3) | 0x41000000):
	          (0x54000000)));

      if(i+4 > length) break; /* i.e. i+3 > length-1 ? */
		 
      db[i+3] = ((4*i+12 >= dblen)?  0x00 :
	        (((0x03000000 & dbc[i/4]) ^ 0x02000000)?
		(((unsigned long)(0x03000000 & dbc[i/4]) >> 23) | 0x00000041):
	          (0x00000054)))|
		((4*i+13 >= dblen)?  0x00 :
		(((0x0C000000 & dbc[i/4]) ^ 0x08000000)?
		(((unsigned long)(0x0C000000 & dbc[i/4]) >> 17) | 0x00004100):
	          (0x00005400)))|
		((4*i+14 >= dblen)?  0x00 :
		(((0x30000000 & dbc[i/4]) ^ 0x20000000)?
		(((unsigned long)(0x30000000 & dbc[i/4]) >> 11) | 0x00410000):
	          (0x00540000)))|
		((4*i+15 >= dblen)?  0x00 :
		(((0xC0000000 & dbc[i/4]) ^ 0x80000000)?
		(((unsigned long)(0xC0000000 & dbc[i/4]) >>  5) | 0x41000000):
	          (0x54000000)));
      break;
	
    case 4:
      for(i=0; i<length-2; i+=2)
      {
        db[i]   = (bit4[                0x0000000F & dbc[i/2]])              |
	          (bit4[(unsigned long)(0x000000F0 & dbc[i/2]) >>  4] <<  8) |
	          (bit4[(unsigned long)(0x00000F00 & dbc[i/2]) >>  8] << 16) |
	          (bit4[(unsigned long)(0x0000F000 & dbc[i/2]) >> 12] << 24);
	
	db[i+1] = (bit4[(unsigned long)(0x000F0000 & dbc[i/2]) >> 16])       |
	          (bit4[(unsigned long)(0x00F00000 & dbc[i/2]) >> 20] <<  8) |
	          (bit4[(unsigned long)(0x0F000000 & dbc[i/2]) >> 24] << 16) |
	          (bit4[(unsigned long)(0xF0000000 & dbc[i/2]) >> 28] << 24);
      }
      db[i]   = ((4*i >= dblen)? 0x00 :            /* out of chars? */
                (bit4[                0x0000000F & dbc[i/2]]))              |
		((4*i+1 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x000000F0 & dbc[i/2]) >>  4] <<  8)) |
		((4*i+2 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x00000F00 & dbc[i/2]) >>  8] << 16)) |
		((4*i+3 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x0000F000 & dbc[i/2]) >> 12] << 24));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		 
      db[i+1] = ((4*i+4 >= dblen)? 0x00 :          /* out of chars? */
                (bit4[(unsigned long)(0x000F0000 & dbc[i/2]) >> 16]))       |
		((4*i+5 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x00F00000 & dbc[i/2]) >> 20] <<  8)) |
		((4*i+6 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0x0F000000 & dbc[i/2]) >> 24] << 16)) |
		((4*i+7 >= dblen)? 0x00 :
	        (bit4[(unsigned long)(0xF0000000 & dbc[i/2]) >> 28] << 24));
      break;
	
    case 5:
      for(i=0; i<length-3; i+=3)
      {
        db[i]   = (((unsigned long)(0x0000007C & dbc[(2*i)/3])   >>  2)  |
	           ((unsigned long)(0x00000F80 & dbc[(2*i)/3])   <<  1)  |
	           ((unsigned long)(0x0001F000 & dbc[(2*i)/3])   <<  4)  |
	           ((unsigned long)(0x003E0000 & dbc[(2*i)/3])   <<  7)) | 0x40404040;
		   
	db[i+1] = (((unsigned long)(0x07C00000 & dbc[(2*i)/3])   >> 22)  |
	           ((unsigned long)(0xF8000000 & dbc[(2*i)/3])   >> 19)  |
	           ((unsigned long)(0x0000007C & dbc[(2*i)/3+1]) << 14)  |
		   ((unsigned long)(0x00000F80 & dbc[(2*i)/3+1]) << 17)) | 0x40404040;
	
	db[i+2] = (((unsigned long)(0x0001F000 & dbc[(2*i)/3+1]) >> 12)  |
	           ((unsigned long)(0x003E0000 & dbc[(2*i)/3+1]) >>  9)  |
		   ((unsigned long)(0x07C00000 & dbc[(2*i)/3+1]) >>  6)  |
		   ((unsigned long)(0xF8000000 & dbc[(2*i)/3+1]) >>  3)) | 0x40404040;
      }
      db[i]   = ((4*i   >= dblen)? 0x00 :          /* out of chars? */
                (( (unsigned long)(0x0000007C & dbc[(2*i)/3])   >>  2) | 0x00000040)) |
		((4*i+1 >= dblen)? 0x00 :
	        (( (unsigned long)(0x00000F80 & dbc[(2*i)/3])   <<  1) | 0x00004000)) |
		((4*i+2 >= dblen)? 0x00 :
	        (( (unsigned long)(0x0001F000 & dbc[(2*i)/3])   <<  4) | 0x00400000)) |
		((4*i+3 >= dblen)? 0x00 :
	        (( (unsigned long)(0x003E0000 & dbc[(2*i)/3])   <<  7) | 0x40000000));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		   
      db[i+1] = ((4*i+4 >= dblen)? 0x00 :
                (( (unsigned long)(0x07C00000 & dbc[(2*i)/3])   >> 22) | 0x00000040)) |
		((4*i+5 >= dblen)? 0x00 :
	        (( (unsigned long)(0xF8000000 & dbc[(2*i)/3])   >> 19) | 0x00004000)) |
		((4*i+6 >= dblen)? 0x00 :
	        (( (unsigned long)(0x0000007C & dbc[(2*i)/3+1]) << 14) | 0x00400000)) |
		((4*i+7 >= dblen)? 0x00 :
		(( (unsigned long)(0x00000F80 & dbc[(2*i)/3+1]) << 17) | 0x40000000));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
	
      db[i+2] = ((4*i+8 >= dblen)? 0x00 :
                (( (unsigned long)(0x0001F000 & dbc[(2*i)/3+1]) >> 12) | 0x00000040)) |
		((4*i+9 >= dblen)? 0x00 :
	        (( (unsigned long)(0x003E0000 & dbc[(2*i)/3+1]) >>  9) | 0x00004000)) |
		((4*i+10>= dblen)? 0x00 :
		(( (unsigned long)(0x07C00000 & dbc[(2*i)/3+1]) >>  6) | 0x00400000)) |
		((4*i+11>= dblen)? 0x00 :
		(( (unsigned long)(0xF8000000 & dbc[(2*i)/3+1]) >>  3) | 0x40000000));
      break;
#endif /* little-endian */

    default:
      fprintf(stderr, "cb_compress: Invalid mode parameter %d, returning...\n", mode);
      return;
  }
#endif /* 32 bit */

#ifdef LONG64
  length = (dblen+7)/8;
  switch (mode)
  {
#ifdef B_ENDIAN
    case 2:
#pragma vdir nodep altcode
#pragma _CRI ivdep
      for(i=0; i<length-4; i+=4)
      {
	db[i]   = (((0xC000000000000000 & dbc[i/4]) == 0x8000000000000000)? /* is it a T? */
	            (0x5400000000000000):
	          (((unsigned long)(0xC000000000000000 & dbc[i/4]) >>  5) | 0x4100000000000000)) |
		  (((0x3000000000000000 & dbc[i/4]) == 0x2000000000000000)? /* is it a T? */
	            (0x0054000000000000):
	          (((unsigned long)(0x3000000000000000 & dbc[i/4]) >> 11) | 0x0041000000000000)) |
		  (((0x0C00000000000000 & dbc[i/4]) == 0x0800000000000000)? /* is it a T? */
	            (0x0000540000000000):
	          (((unsigned long)(0x0C00000000000000 & dbc[i/4]) >> 17) | 0x0000410000000000)) |
		  (((0x0300000000000000 & dbc[i/4]) == 0x0200000000000000)? /* is it a T? */
	            (0x0000005400000000):
	          (((unsigned long)(0x0300000000000000 & dbc[i/4]) >> 23) | 0x0000004100000000)) |
		  (((0x00C0000000000000 & dbc[i/4]) == 0x0080000000000000)? /* is it a T? */
	            (0x0000000054000000):
	          (((unsigned long)(0x00C0000000000000 & dbc[i/4]) >> 29) | 0x0000000041000000)) |
		  (((0x0030000000000000 & dbc[i/4]) == 0x0020000000000000)? /* is it a T? */
	            (0x0000000000540000):
	          (((unsigned long)(0x0030000000000000 & dbc[i/4]) >> 35) | 0x0000000000410000)) |
		  (((0x000C000000000000 & dbc[i/4]) == 0x0008000000000000)? /* is it a T? */
	            (0x0000000000005400):
	          (((unsigned long)(0x000C000000000000 & dbc[i/4]) >> 41) | 0x0000000000004100)) |
		  (((0x0003000000000000 & dbc[i/4]) == 0x0002000000000000)? /* is it a T? */
	            (0x0000000000000054):
	          (((unsigned long)(0x0003000000000000 & dbc[i/4]) >> 47) | 0x0000000000000041));
		       
	db[i+1] = (((0x0000C00000000000 & dbc[i/4]) == 0x0000800000000000)?
	            (0x5400000000000000):
	          (((0x0000C00000000000 & dbc[i/4]) << 11) | 0x4100000000000000)) |
		  (((0x0000300000000000 & dbc[i/4]) == 0x0000200000000000)?
	            (0x0054000000000000):
	          (((0x0000300000000000 & dbc[i/4]) <<  5) | 0x0041000000000000)) |
		  (((0x00000C0000000000 & dbc[i/4]) == 0x0000080000000000)?
	            (0x0000540000000000):
	          (((unsigned long)(0x00000C0000000000 & dbc[i/4]) >>  1) | 0x0000410000000000)) |
		  (((0x0000030000000000 & dbc[i/4]) == 0x0000020000000000)?
	            (0x0000005400000000):
	          (((unsigned long)(0x0000030000000000 & dbc[i/4]) >>  7) | 0x0000004100000000)) |
		  (((0x000000C000000000 & dbc[i/4]) == 0x0000008000000000)?
	            (0x0000000054000000):
	          (((unsigned long)(0x000000C000000000 & dbc[i/4]) >> 13) | 0x0000000041000000)) |
		  (((0x0000003000000000 & dbc[i/4]) == 0x0000002000000000)? 
	            (0x0000000000540000):
	          (((unsigned long)(0x0000003000000000 & dbc[i/4]) >> 19) | 0x0000000000410000)) |
		  (((0x0000000C00000000 & dbc[i/4]) == 0x0000000800000000)?
	            (0x0000000000005400):
	          (((unsigned long)(0x0000000C00000000 & dbc[i/4]) >> 25) | 0x0000000000004100)) |
		  (((0x0000000300000000 & dbc[i/4]) == 0x0000000200000000)?
	            (0x0000000000000054):
	          (((unsigned long)(0x0000000300000000 & dbc[i/4]) >> 31) | 0x0000000000000041));
		       
	db[i+2] = (((0x00000000C0000000 & dbc[i/4]) == 0x0000000080000000)?
	            (0x5400000000000000):
	          (((0x00000000C0000000 & dbc[i/4]) << 27) | 0x4100000000000000)) |
		  (((0x0000000030000000 & dbc[i/4]) == 0x0000000020000000)?
	            (0x0054000000000000):
	          (((0x0000000030000000 & dbc[i/4]) << 21) | 0x0041000000000000)) |
		  (((0x000000000C000000 & dbc[i/4]) == 0x0000000008000000)?
	            (0x0000540000000000):
	          (((0x000000000C000000 & dbc[i/4]) << 15) | 0x0000410000000000)) |
		  (((0x0000000003000000 & dbc[i/4]) == 0x0000000002000000)?
	            (0x0000005400000000):
	          (((0x0000000003000000 & dbc[i/4]) <<  9) | 0x0000004100000000)) |
		  (((0x0000000000C00000 & dbc[i/4]) == 0x0000000000800000)?
	            (0x0000000054000000):
	          (((0x0000000000C00000 & dbc[i/4]) <<  3) | 0x0000000041000000)) |
		  (((0x0000000000300000 & dbc[i/4]) == 0x0000000000200000)? 
	            (0x0000000000540000):
	          (((unsigned long)(0x0000000000300000 & dbc[i/4]) >>  3) | 0x0000000000410000)) |
		  (((0x00000000000C0000 & dbc[i/4]) == 0x0000000000080000)?
	            (0x0000000000005400):
	          (((unsigned long)(0x00000000000C0000 & dbc[i/4]) >>  9) | 0x0000000000004100)) |
		  (((0x0000000000030000 & dbc[i/4]) == 0x0000000000020000)?
	            (0x0000000000000054):
	          (((unsigned long)(0x0000000000030000 & dbc[i/4]) >> 15) | 0x0000000000000041));
		       
	db[i+3] = (((0x000000000000C000 & dbc[i/4]) == 0x0000000000008000)?
	            (0x5400000000000000):
	          (((0x000000000000C000 & dbc[i/4]) << 43) | 0x4100000000000000)) |
		  (((0x0000000000003000 & dbc[i/4]) == 0x0000000000002000)?
	            (0x0054000000000000):
	          (((0x0000000000003000 & dbc[i/4]) << 37) | 0x0041000000000000)) |
		  (((0x0000000000000C00 & dbc[i/4]) == 0x0000000000000800)?
	            (0x0000540000000000):
	          (((0x0000000000000C00 & dbc[i/4]) << 31) | 0x0000410000000000)) |
		  (((0x0000000000000300 & dbc[i/4]) == 0x0000000000000200)?
	            (0x0000005400000000):
	          (((0x0000000000000300 & dbc[i/4]) << 25) | 0x0000004100000000)) |
		  (((0x00000000000000C0 & dbc[i/4]) == 0x0000000000000080)?
	            (0x0000000054000000):
	          (((0x00000000000000C0 & dbc[i/4]) << 19) | 0x0000000041000000)) |
		  (((0x0000000000000030 & dbc[i/4]) == 0x0000000000000020)? 
	            (0x0000000000540000):
	          (((0x0000000000000030 & dbc[i/4]) << 13) | 0x0000000000410000)) |
		  (((0x000000000000000C & dbc[i/4]) == 0x0000000000000008)?
	            (0x0000000000005400):
	          (((0x000000000000000C & dbc[i/4]) <<  7) | 0x0000000000004100)) |
		  (((0x0000000000000003 & dbc[i/4]) == 0x0000000000000002)?
	            (0x0000000000000054):
	          (((0x0000000000000003 & dbc[i/4]) <<  1) | 0x0000000000000041));
      }
      db[i]   = ((8*i   >= dblen)? 0x00 :       /* out of chars? */
                (((0xC000000000000000 & dbc[i/4]) == 0x8000000000000000)? /* is it a T? */
	          (0x5400000000000000):
	        (((unsigned long)(0xC000000000000000 & dbc[i/4]) >>  5) | 0x4100000000000000))) |
		((8*i+1 >= dblen)? 0x00 :
		(((0x3000000000000000 & dbc[i/4]) == 0x2000000000000000)? /* is it a T? */
	          (0x0054000000000000):
	        (((unsigned long)(0x3000000000000000 & dbc[i/4]) >> 11) | 0x0041000000000000))) |
		((8*i+2 >= dblen)? 0x00 :
		(((0x0C00000000000000 & dbc[i/4]) == 0x0800000000000000)? /* is it a T? */
	          (0x0000540000000000):
	        (((unsigned long)(0x0C00000000000000 & dbc[i/4]) >> 17) | 0x0000410000000000))) |
		((8*i+3 >= dblen)? 0x00 :
		(((0x0300000000000000 & dbc[i/4]) == 0x0200000000000000)? /* is it a T? */
	          (0x0000005400000000):
	        (((unsigned long)(0x0300000000000000 & dbc[i/4]) >> 23) | 0x0000004100000000))) |
		((8*i+4 >= dblen)? 0x00 :
		(((0x00C0000000000000 & dbc[i/4]) == 0x0080000000000000)? /* is it a T? */
	          (0x0000000054000000):
	        (((unsigned long)(0x00C0000000000000 & dbc[i/4]) >> 29) | 0x0000000041000000))) |
		((8*i+5 >= dblen)? 0x00 :
		(((0x0030000000000000 & dbc[i/4]) == 0x0020000000000000)? /* is it a T? */
	          (0x0000000000540000):
	        (((unsigned long)(0x0030000000000000 & dbc[i/4]) >> 35) | 0x0000000000410000))) |
		((8*i+6 >= dblen)? 0x00 :
		(((0x000C000000000000 & dbc[i/4]) == 0x0008000000000000)? /* is it a T? */
	          (0x0000000000005400):
	        (((unsigned long)(0x000C000000000000 & dbc[i/4]) >> 41) | 0x0000000000004100))) |
		((8*i+7 >= dblen)? 0x00 :
		(((0x0003000000000000 & dbc[i/4]) == 0x0002000000000000)? /* is it a T? */
	          (0x0000000000000054):
	        (((unsigned long)(0x0003000000000000 & dbc[i/4]) >> 47) | 0x0000000000000041)));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		       
      db[i+1] = ((8*i+8 >= dblen)? 0x00 :
                (((0x0000C00000000000 & dbc[i/4]) == 0x0000800000000000)?
	          (0x5400000000000000):
	        (((unsigned long)(0x0000C00000000000 & dbc[i/4]) << 11) | 0x4100000000000000))) |
		((8*i+9 >= dblen)? 0x00 :
		(((0x0000300000000000 & dbc[i/4]) == 0x0000200000000000)?
	          (0x0054000000000000):
	        (((unsigned long)(0x0000300000000000 & dbc[i/4]) <<  5) | 0x0041000000000000))) |
		((8*i+10>= dblen)? 0x00 :
		(((0x00000C0000000000 & dbc[i/4]) == 0x0000080000000000)?
	          (0x0000540000000000):
	        (((unsigned long)(0x00000C0000000000 & dbc[i/4]) >>  1) | 0x0000410000000000))) |
		((8*i+11>= dblen)? 0x00 :
		(((0x0000030000000000 & dbc[i/4]) == 0x0000020000000000)?
	          (0x0000005400000000):
	        (((unsigned long)(0x0000030000000000 & dbc[i/4]) >>  7) | 0x0000004100000000))) |
		((8*i+12>= dblen)? 0x00 :
		(((0x000000C000000000 & dbc[i/4]) == 0x0000008000000000)?
	          (0x0000000054000000):
	        (((unsigned long)(0x000000C000000000 & dbc[i/4]) >> 13) | 0x0000000041000000))) |
		((8*i+13>= dblen)? 0x00 :
		(((0x0000003000000000 & dbc[i/4]) == 0x0000002000000000)? 
	          (0x0000000000540000):
	        (((unsigned long)(0x0000003000000000 & dbc[i/4]) >> 19) | 0x0000000000410000))) |
		((8*i+14>= dblen)? 0x00 :
		(((0x0000000C00000000 & dbc[i/4]) == 0x0000000800000000)?
	          (0x0000000000005400):
	        (((unsigned long)(0x0000000C00000000 & dbc[i/4]) >> 25) | 0x0000000000004100))) |
		((8*i+15>= dblen)? 0x00 :
		(((0x0000000300000000 & dbc[i/4]) == 0x0000000200000000)?
	          (0x0000000000000054):
	        (((unsigned long)(0x0000000300000000 & dbc[i/4]) >> 31) | 0x0000000000000041)));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
		       
      db[i+2] = ((8*i+16>= dblen)? 0x00 :
                (((0x00000000C0000000 & dbc[i/4]) == 0x0000000080000000)?
	          (0x5400000000000000):
	        (((0x00000000C0000000 & dbc[i/4]) << 27) | 0x4100000000000000))) |
		((8*i+17>= dblen)? 0x00 :
		(((0x0000000030000000 & dbc[i/4]) == 0x0000000020000000)?
	          (0x0054000000000000):
	        (((0x0000000030000000 & dbc[i/4]) << 21) | 0x0041000000000000))) |
		((8*i+18>= dblen)? 0x00 :
		(((0x000000000C000000 & dbc[i/4]) == 0x0000000008000000)?
	          (0x0000540000000000):
	        (((0x000000000C000000 & dbc[i/4]) << 15) | 0x0000410000000000))) |
		((8*i+19>= dblen)? 0x00 :
		(((0x0000000003000000 & dbc[i/4]) == 0x0000000002000000)?
	          (0x0000005400000000):
	        (((0x0000000003000000 & dbc[i/4]) <<  9) | 0x0000004100000000))) |
		((8*i+20>= dblen)? 0x00 :
		(((0x0000000000C00000 & dbc[i/4]) == 0x0000000000800000)?
	          (0x0000000054000000):
	        (((0x0000000000C00000 & dbc[i/4]) <<  3) | 0x0000000041000000))) |
		((8*i+21>= dblen)? 0x00 :
		(((0x0000000000300000 & dbc[i/4]) == 0x0000000000200000)? 
	          (0x0000000000540000):
	        (((unsigned long)(0x0000000000300000 & dbc[i/4]) >>  3) | 0x0000000000410000))) |
		((8*i+22>= dblen)? 0x00 :
		(((0x00000000000C0000 & dbc[i/4]) == 0x0000000000080000)?
	          (0x0000000000005400):
	        (((unsigned long)(0x00000000000C0000 & dbc[i/4]) >>  9) | 0x0000000000004100))) |
		((8*i+23>= dblen)? 0x00 :
		(((0x0000000000030000 & dbc[i/4]) == 0x0000000000020000)?
	          (0x0000000000000054):
	        (((unsigned long)(0x0000000000030000 & dbc[i/4]) >> 15) | 0x0000000000000041)));

      if(i+4 > length) break; /* i.e. i+3 > length-1 ? */
		       
      db[i+3] = ((8*i+24>= dblen)? 0x00 :
                (((0x000000000000C000 & dbc[i/4]) == 0x0000000000008000)?
	          (0x5400000000000000):
	        (((0x000000000000C000 & dbc[i/4]) << 43) | 0x4100000000000000))) |
		((8*i+25>= dblen)? 0x00 :
		(((0x0000000000003000 & dbc[i/4]) == 0x0000000000002000)?
	          (0x0054000000000000):
	        (((0x0000000000003000 & dbc[i/4]) << 37) | 0x0041000000000000))) |
		((8*i+26>= dblen)? 0x00 :
		(((0x0000000000000C00 & dbc[i/4]) == 0x0000000000000800)?
	          (0x0000540000000000):
	        (((0x0000000000000C00 & dbc[i/4]) << 31) | 0x0000410000000000))) |
		((8*i+27>= dblen)? 0x00 :
		(((0x0000000000000300 & dbc[i/4]) == 0x0000000000000200)?
	          (0x0000005400000000):
	        (((0x0000000000000300 & dbc[i/4]) << 25) | 0x0000004100000000))) |
		((8*i+28>= dblen)? 0x00 :
		(((0x00000000000000C0 & dbc[i/4]) == 0x0000000000000080)?
	          (0x0000000054000000):
	        (((0x00000000000000C0 & dbc[i/4]) << 19) | 0x0000000041000000))) |
		((8*i+29>= dblen)? 0x00 :
		(((0x0000000000000030 & dbc[i/4]) == 0x0000000000000020)? 
	          (0x0000000000540000):
	        (((0x0000000000000030 & dbc[i/4]) << 13) | 0x0000000000410000))) |
		((8*i+30>= dblen)? 0x00 :
		(((0x000000000000000C & dbc[i/4]) == 0x0000000000000008)?
	          (0x0000000000005400):
	        (((0x000000000000000C & dbc[i/4]) <<  7) | 0x0000000000004100))) |
		((8*i+31>= dblen)? 0x00 :
		(((0x0000000000000003 & dbc[i/4]) == 0x0000000000000002)?
	          (0x0000000000000054):
	        (((0x0000000000000003 & dbc[i/4]) <<  1) | 0x0000000000000041)));
      
      break;
	
    case 4:
#pragma vdir nodep altcode
#pragma _CRI ivdep
      for(i=0; i<length-2; i+=2)
      {
        db[i]   = (bit4[(unsigned long)(0xF000000000000000 & dbc[i/2]) >> 60] << 56) |
	          (bit4[(unsigned long)(0x0F00000000000000 & dbc[i/2]) >> 56] << 48) |
	          (bit4[(unsigned long)(0x00F0000000000000 & dbc[i/2]) >> 52] << 40) |
	          (bit4[(unsigned long)(0x000F000000000000 & dbc[i/2]) >> 48] << 32) |
	          (bit4[(unsigned long)(0x0000F00000000000 & dbc[i/2]) >> 44] << 24) |
	          (bit4[(unsigned long)(0x00000F0000000000 & dbc[i/2]) >> 40] << 16) |
	          (bit4[(unsigned long)(0x000000F000000000 & dbc[i/2]) >> 36] <<  8) |
	          (bit4[(unsigned long)(0x0000000F00000000 & dbc[i/2]) >> 32]);
        
	db[i+1] = (bit4[(unsigned long)(0x00000000F0000000 & dbc[i/2]) >> 28] << 56) |
	          (bit4[(unsigned long)(0x000000000F000000 & dbc[i/2]) >> 24] << 48) |
	          (bit4[(unsigned long)(0x0000000000F00000 & dbc[i/2]) >> 20] << 40) |
	          (bit4[(unsigned long)(0x00000000000F0000 & dbc[i/2]) >> 16] << 32) |
	          (bit4[(unsigned long)(0x000000000000F000 & dbc[i/2]) >> 12] << 24) |
	          (bit4[(unsigned long)(0x0000000000000F00 & dbc[i/2]) >>  8] << 16) |
	          (bit4[(unsigned long)(0x00000000000000F0 & dbc[i/2]) >>  4] <<  8) |
	          (bit4[(unsigned long)(0x000000000000000F & dbc[i/2])]);
      }
      db[i]   = ((8*i   >= dblen)?    0x00 :     /* out of chars? */
                (bit4[(unsigned long)(0xF000000000000000 & dbc[i/2]) >> 60] << 56)) |
		((8*i+1 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0F00000000000000 & dbc[i/2]) >> 56] << 48)) |
		((8*i+2 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00F0000000000000 & dbc[i/2]) >> 52] << 40)) |
		((8*i+3 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000F000000000000 & dbc[i/2]) >> 48] << 32)) |
		((8*i+4 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000F00000000000 & dbc[i/2]) >> 44] << 24)) |
		((8*i+5 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00000F0000000000 & dbc[i/2]) >> 40] << 16)) |
		((8*i+6 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000000F000000000 & dbc[i/2]) >> 36] <<  8)) |
		((8*i+7 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000000F00000000 & dbc[i/2]) >> 32]));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
        
      db[i+1] = ((8*i+8 >= dblen)?    0x00 :
                (bit4[(unsigned long)(0x00000000F0000000 & dbc[i/2]) >> 28] << 56)) |
		((8*i+9 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000000000F000000 & dbc[i/2]) >> 24] << 48)) |
		((8*i+10>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000000000F00000 & dbc[i/2]) >> 20] << 40)) |
		((8*i+11>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00000000000F0000 & dbc[i/2]) >> 16] << 32)) |
		((8*i+12>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000000000000F000 & dbc[i/2]) >> 12] << 24)) |
		((8*i+13>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000000000000F00 & dbc[i/2]) >>  8] << 16)) |
		((8*i+14>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00000000000000F0 & dbc[i/2]) >>  4] <<  8)) |
		((8*i+15>= dblen)?    0x00 :
	        (bit4[                0x000000000000000F & dbc[i/2]]));
      break;
	
    case 5:
#pragma vdir nodep altcode
#pragma _CRI ivdep
      for(i=0; i<length-3; i+=3)
      {
        db[i]   = ((               (0x0F80000000000000 & dbc[(2*i)/3])   <<  1)  |
	           ((unsigned long)(0x007C000000000000 & dbc[(2*i)/3])   >>  2)  |
	           ((unsigned long)(0x0003E00000000000 & dbc[(2*i)/3])   >>  5)  |
	           ((unsigned long)(0x00001F0000000000 & dbc[(2*i)/3])   >>  8)  |
		   ((unsigned long)(0x000000F800000000 & dbc[(2*i)/3])   >> 11)  |
		   ((unsigned long)(0x00000007C0000000 & dbc[(2*i)/3])   >> 14)  |
		   ((unsigned long)(0x000000003E000000 & dbc[(2*i)/3])   >> 17)  |
		   ((unsigned long)(0x0000000001F00000 & dbc[(2*i)/3])   >> 20)) | 
		                    0x4040404040404040;
		   
	db[i+1] = ((               (0x00000000000F8000 & dbc[(2*i)/3])   << 41)  |
	           (               (0x0000000000007C00 & dbc[(2*i)/3])   << 38)  |
	           (               (0x00000000000003E0 & dbc[(2*i)/3])   << 35)  |
		   (               (0x000000000000001F & dbc[(2*i)/3])   << 32)  |
		   ((unsigned long)(0x0F80000000000000 & dbc[(2*i)/3+1]) >> 31)  |
	           ((unsigned long)(0x007C000000000000 & dbc[(2*i)/3+1]) >> 34)  |
	           ((unsigned long)(0x0003E00000000000 & dbc[(2*i)/3+1]) >> 37)  |
	           ((unsigned long)(0x00001F0000000000 & dbc[(2*i)/3+1]) >> 40)) | 
		                    0x4040404040404040;
	
	db[i+2] = (((0x000000F800000000 & dbc[(2*i)/3+1]) << 21)  |
	           ((0x00000007C0000000 & dbc[(2*i)/3+1]) << 18)  |
	           ((0x000000003E000000 & dbc[(2*i)/3+1]) << 15)  |
	           ((0x0000000001F00000 & dbc[(2*i)/3+1]) << 12)  |
		   ((0x00000000000F8000 & dbc[(2*i)/3+1]) <<  9)  |
		   ((0x0000000000007C00 & dbc[(2*i)/3+1]) <<  6)  |
		   ((0x00000000000003E0 & dbc[(2*i)/3+1]) <<  3)  |
		   ((0x000000000000001F & dbc[(2*i)/3+1])))       | 
		     0x4040404040404040;
      }
      db[i]   = ((8*i   >= dblen)? 0x00 :   /* out of chars? */
                ((                (0x0F80000000000000 & dbc[(2*i)/3])   <<  1) | 0x4000000000000000)) |
	        ((8*i+1 >= dblen)? 0x00 :
		(( (unsigned long)(0x007C000000000000 & dbc[(2*i)/3])   >>  2) | 0x0040000000000000)) |
	        ((8*i+2 >= dblen)? 0x00 :
		(( (unsigned long)(0x0003E00000000000 & dbc[(2*i)/3])   >>  5) | 0x0000400000000000)) |
	        ((8*i+3 >= dblen)? 0x00 :
		(( (unsigned long)(0x00001F0000000000 & dbc[(2*i)/3])   >>  8) | 0x0000004000000000)) |
		((8*i+4 >= dblen)? 0x00 :
		(( (unsigned long)(0x000000F800000000 & dbc[(2*i)/3])   >> 11) | 0x0000000040000000)) |
		((8*i+5 >= dblen)? 0x00 :
		(( (unsigned long)(0x00000007C0000000 & dbc[(2*i)/3])   >> 14) | 0x0000000000400000)) |
		((8*i+6 >= dblen)? 0x00 :
		(( (unsigned long)(0x000000003E000000 & dbc[(2*i)/3])   >> 17) | 0x0000000000004000)) |
		((8*i+7 >= dblen)? 0x00 :
		(( (unsigned long)(0x0000000001F00000 & dbc[(2*i)/3])   >> 20) | 0x0000000000000040));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		   
      db[i+1] = ((8*i+8 >= dblen)? 0x00 :
                ((                (0x00000000000F8000 & dbc[(2*i)/3])   << 41) | 0x4000000000000000)) |
	        ((8*i+9 >= dblen)? 0x00 :
		((                (0x0000000000007C00 & dbc[(2*i)/3])   << 38) | 0x0040000000000000)) |
	        ((8*i+10>= dblen)? 0x00 :
		((                (0x00000000000003E0 & dbc[(2*i)/3])   << 35) | 0x0000400000000000)) |
		((8*i+11>= dblen)? 0x00 :
		((                (0x000000000000001F & dbc[(2*i)/3])   << 32) | 0x0000004000000000)) |
		((8*i+12>= dblen)? 0x00 :
		(( (unsigned long)(0x0F80000000000000 & dbc[(2*i)/3+1]) >> 31) | 0x0000000040000000)) |
	        ((8*i+13>= dblen)? 0x00 :
		(( (unsigned long)(0x007C000000000000 & dbc[(2*i)/3+1]) >> 34) | 0x0000000000400000)) |
	        ((8*i+14>= dblen)? 0x00 :
		(( (unsigned long)(0x0003E00000000000 & dbc[(2*i)/3+1]) >> 37) | 0x0000000000004000)) |
	        ((8*i+15>= dblen)? 0x00 :
		(( (unsigned long)(0x00001F0000000000 & dbc[(2*i)/3+1]) >> 40) | 0x0000000000000040));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
	
      db[i+2] = ((8*i+16>= dblen)? 0x00 :
                (((0x000000F800000000 & dbc[(2*i)/3+1]) << 21) | 0x4000000000000000)) |
	        ((8*i+17>= dblen)? 0x00 :
		(((0x00000007C0000000 & dbc[(2*i)/3+1]) << 18) | 0x0040000000000000)) |
	        ((8*i+18>= dblen)? 0x00 :
		(((0x000000003E000000 & dbc[(2*i)/3+1]) << 15) | 0x0000400000000000)) |
	        ((8*i+19>= dblen)? 0x00 :
		(((0x0000000001F00000 & dbc[(2*i)/3+1]) << 12) | 0x0000004000000000)) |
		((8*i+20>= dblen)? 0x00 :
		(((0x00000000000F8000 & dbc[(2*i)/3+1]) <<  9) | 0x0000000040000000)) |
		((8*i+21>= dblen)? 0x00 :
		(((0x0000000000007C00 & dbc[(2*i)/3+1]) <<  6) | 0x0000000000400000)) |
		((8*i+22>= dblen)? 0x00 :
		(((0x00000000000003E0 & dbc[(2*i)/3+1]) <<  3) | 0x0000000000004000)) |
		((8*i+23>= dblen)? 0x00 :
		(((0x000000000000001F & dbc[(2*i)/3+1]))       | 0x0000000000000040));
      break;
#endif /* big-endian */
#ifdef L_ENDIAN
case 2:
      for(i=0; i<length-4; i+=4)
      {
	db[i]   = (((0x000000000000C000 & dbc[i/4]) == 0x0000000000008000)?
	            (0x5400000000000000):
	          (((0x000000000000C000 & dbc[i/4]) << 43) | 0x4100000000000000)) |
		  (((0x0000000000003000 & dbc[i/4]) == 0x0000000000002000)?
	            (0x0054000000000000):
	          (((0x0000000000003000 & dbc[i/4]) << 37) | 0x0041000000000000)) |
		  (((0x0000000000000C00 & dbc[i/4]) == 0x0000000000000800)?
	            (0x0000540000000000):
	          (((0x0000000000000C00 & dbc[i/4]) << 31) | 0x0000410000000000)) |
		  (((0x0000000000000300 & dbc[i/4]) == 0x0000000000000200)?
	            (0x0000005400000000):
	          (((0x0000000000000300 & dbc[i/4]) << 25) | 0x0000004100000000)) |
		  (((0x00000000000000C0 & dbc[i/4]) == 0x0000000000000080)?
	            (0x0000000054000000):
	          (((0x00000000000000C0 & dbc[i/4]) << 19) | 0x0000000041000000)) |
		  (((0x0000000000000030 & dbc[i/4]) == 0x0000000000000020)? 
	            (0x0000000000540000):
	          (((0x0000000000000030 & dbc[i/4]) << 13) | 0x0000000000410000)) |
		  (((0x000000000000000C & dbc[i/4]) == 0x0000000000000008)?
	            (0x0000000000005400):
	          (((0x000000000000000C & dbc[i/4]) <<  7) | 0x0000000000004100)) |
		  (((0x0000000000000003 & dbc[i/4]) == 0x0000000000000002)?
	            (0x0000000000000054):
	          (((0x0000000000000003 & dbc[i/4]) <<  1) | 0x0000000000000041));
		       
	db[i+1] = (((0x00000000C0000000 & dbc[i/4]) == 0x0000000080000000)?
	            (0x5400000000000000):
	          (((0x00000000C0000000 & dbc[i/4]) << 27) | 0x4100000000000000)) |
		  (((0x0000000030000000 & dbc[i/4]) == 0x0000000020000000)?
	            (0x0054000000000000):
	          (((0x0000000030000000 & dbc[i/4]) << 21) | 0x0041000000000000)) |
		  (((0x000000000C000000 & dbc[i/4]) == 0x0000000008000000)?
	            (0x0000540000000000):
	          (((0x000000000C000000 & dbc[i/4]) << 15) | 0x0000410000000000)) |
		  (((0x0000000003000000 & dbc[i/4]) == 0x0000000002000000)?
	            (0x0000005400000000):
	          (((0x0000000003000000 & dbc[i/4]) <<  9) | 0x0000004100000000)) |
		  (((0x0000000000C00000 & dbc[i/4]) == 0x0000000000800000)?
	            (0x0000000054000000):
	          (((0x0000000000C00000 & dbc[i/4]) <<  3) | 0x0000000041000000)) |
		  (((0x0000000000300000 & dbc[i/4]) == 0x0000000000200000)? 
	            (0x0000000000540000):
	          (((unsigned long)(0x0000000000300000 & dbc[i/4]) >>  3) | 0x0000000000410000)) |
		  (((0x00000000000C0000 & dbc[i/4]) == 0x0000000000080000)?
	            (0x0000000000005400):
	          (((unsigned long)(0x00000000000C0000 & dbc[i/4]) >>  9) | 0x0000000000004100)) |
		  (((0x0000000000030000 & dbc[i/4]) == 0x0000000000020000)?
	            (0x0000000000000054):
	          (((unsigned long)(0x0000000000030000 & dbc[i/4]) >> 15) | 0x0000000000000041));
		       
	db[i+2] = (((0x0000C00000000000 & dbc[i/4]) == 0x0000800000000000)?
	            (0x5400000000000000):
	          (((0x0000C00000000000 & dbc[i/4]) << 11) | 0x4100000000000000)) |
		  (((0x0000300000000000 & dbc[i/4]) == 0x0000200000000000)?
	            (0x0054000000000000):
	          (((0x0000300000000000 & dbc[i/4]) <<  5) | 0x0041000000000000)) |
		  (((0x00000C0000000000 & dbc[i/4]) == 0x0000080000000000)?
	            (0x0000540000000000):
	          (((unsigned long)(0x00000C0000000000 & dbc[i/4]) >>  1) | 0x0000410000000000)) |
		  (((0x0000030000000000 & dbc[i/4]) == 0x0000020000000000)?
	            (0x0000005400000000):
	          (((unsigned long)(0x0000030000000000 & dbc[i/4]) >>  7) | 0x0000004100000000)) |
		  (((0x000000C000000000 & dbc[i/4]) == 0x0000008000000000)?
	            (0x0000000054000000):
	          (((unsigned long)(0x000000C000000000 & dbc[i/4]) >> 13) | 0x0000000041000000)) |
		  (((0x0000003000000000 & dbc[i/4]) == 0x0000002000000000)? 
	            (0x0000000000540000):
	          (((unsigned long)(0x0000003000000000 & dbc[i/4]) >> 19) | 0x0000000000410000)) |
		  (((0x0000000C00000000 & dbc[i/4]) == 0x0000000800000000)?
	            (0x0000000000005400):
	          (((unsigned long)(0x0000000C00000000 & dbc[i/4]) >> 25) | 0x0000000000004100)) |
		  (((0x0000000300000000 & dbc[i/4]) == 0x0000000200000000)?
	            (0x0000000000000054):
	          (((unsigned long)(0x0000000300000000 & dbc[i/4]) >> 31) | 0x0000000000000041));
		       
	db[i+3] = (((0xC000000000000000 & dbc[i/4]) == 0x8000000000000000)? /* is it a T? */
	            (0x5400000000000000):
	          (((unsigned long)(0xC000000000000000 & dbc[i/4]) >>  5) | 0x4100000000000000)) |
		  (((0x3000000000000000 & dbc[i/4]) == 0x2000000000000000)? /* is it a T? */
	            (0x0054000000000000):
	          (((unsigned long)(0x3000000000000000 & dbc[i/4]) >> 11) | 0x0041000000000000)) |
		  (((0x0C00000000000000 & dbc[i/4]) == 0x0800000000000000)? /* is it a T? */
	            (0x0000540000000000):
	          (((unsigned long)(0x0C00000000000000 & dbc[i/4]) >> 17) | 0x0000410000000000)) |
		  (((0x0300000000000000 & dbc[i/4]) == 0x0200000000000000)? /* is it a T? */
	            (0x0000005400000000):
	          (((unsigned long)(0x0300000000000000 & dbc[i/4]) >> 23) | 0x0000004100000000)) |
		  (((0x00C0000000000000 & dbc[i/4]) == 0x0080000000000000)? /* is it a T? */
	            (0x0000000054000000):
	          (((unsigned long)(0x00C0000000000000 & dbc[i/4]) >> 29) | 0x0000000041000000)) |
		  (((0x0030000000000000 & dbc[i/4]) == 0x0020000000000000)? /* is it a T? */
	            (0x0000000000540000):
	          (((unsigned long)(0x0030000000000000 & dbc[i/4]) >> 35) | 0x0000000000410000)) |
		  (((0x000C000000000000 & dbc[i/4]) == 0x0008000000000000)? /* is it a T? */
	            (0x0000000000005400):
	          (((unsigned long)(0x000C000000000000 & dbc[i/4]) >> 41) | 0x0000000000004100)) |
		  (((0x0003000000000000 & dbc[i/4]) == 0x0002000000000000)? /* is it a T? */
	            (0x0000000000000054):
	          (((unsigned long)(0x0003000000000000 & dbc[i/4]) >> 47) | 0x0000000000000041));
      }
      db[i]   = ((8*i+7 >= dblen)? 0x00 :
                (((0x000000000000C000 & dbc[i/4]) == 0x0000000000008000)?
	          (0x5400000000000000):
	        (((0x000000000000C000 & dbc[i/4]) << 43) | 0x4100000000000000))) |
		((8*i+6 >= dblen)? 0x00 :
		(((0x0000000000003000 & dbc[i/4]) == 0x0000000000002000)?
	          (0x0054000000000000):
	        (((0x0000000000003000 & dbc[i/4]) << 37) | 0x0041000000000000))) |
		((8*i+5 >= dblen)? 0x00 :
		(((0x0000000000000C00 & dbc[i/4]) == 0x0000000000000800)?
	          (0x0000540000000000):
	        (((0x0000000000000C00 & dbc[i/4]) << 31) | 0x0000410000000000))) |
		((8*i+4 >= dblen)? 0x00 :
		(((0x0000000000000300 & dbc[i/4]) == 0x0000000000000200)?
	          (0x0000005400000000):
	        (((0x0000000000000300 & dbc[i/4]) << 25) | 0x0000004100000000))) |
		((8*i+3 >= dblen)? 0x00 :
		(((0x00000000000000C0 & dbc[i/4]) == 0x0000000000000080)?
	          (0x0000000054000000):
	        (((0x00000000000000C0 & dbc[i/4]) << 19) | 0x0000000041000000))) |
		((8*i+2 >= dblen)? 0x00 :
		(((0x0000000000000030 & dbc[i/4]) == 0x0000000000000020)? 
	          (0x0000000000540000):
	        (((0x0000000000000030 & dbc[i/4]) << 13) | 0x0000000000410000))) |
		((8*i+1 >= dblen)? 0x00 :
		(((0x000000000000000C & dbc[i/4]) == 0x0000000000000008)?
	          (0x0000000000005400):
	        (((0x000000000000000C & dbc[i/4]) <<  7) | 0x0000000000004100))) |
		((8*i   >= dblen)? 0x00 :
		(((0x0000000000000003 & dbc[i/4]) == 0x0000000000000002)?
	          (0x0000000000000054):
	        (((0x0000000000000003 & dbc[i/4]) <<  1) | 0x0000000000000041)));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		       
      db[i+1] = ((8*i+15>= dblen)? 0x00 :
                (((0x00000000C0000000 & dbc[i/4]) == 0x0000000080000000)?
	          (0x5400000000000000):
	        (((0x00000000C0000000 & dbc[i/4]) << 27) | 0x4100000000000000))) |
		((8*i+14>= dblen)? 0x00 :
		(((0x0000000030000000 & dbc[i/4]) == 0x0000000020000000)?
	          (0x0054000000000000):
	        (((0x0000000030000000 & dbc[i/4]) << 21) | 0x0041000000000000))) |
		((8*i+13>= dblen)? 0x00 :
		(((0x000000000C000000 & dbc[i/4]) == 0x0000000008000000)?
	          (0x0000540000000000):
	        (((0x000000000C000000 & dbc[i/4]) << 15) | 0x0000410000000000))) |
		((8*i+12>= dblen)? 0x00 :
		(((0x0000000003000000 & dbc[i/4]) == 0x0000000002000000)?
	          (0x0000005400000000):
	        (((0x0000000003000000 & dbc[i/4]) <<  9) | 0x0000004100000000))) |
		((8*i+11>= dblen)? 0x00 :
		(((0x0000000000C00000 & dbc[i/4]) == 0x0000000000800000)?
	          (0x0000000054000000):
	        (((0x0000000000C00000 & dbc[i/4]) <<  3) | 0x0000000041000000))) |
		((8*i+10>= dblen)? 0x00 :
		(((0x0000000000300000 & dbc[i/4]) == 0x0000000000200000)? 
	          (0x0000000000540000):
	        (((unsigned long)(0x0000000000300000 & dbc[i/4]) >>  3) | 0x0000000000410000))) |
		((8*i+9 >= dblen)? 0x00 :
		(((0x00000000000C0000 & dbc[i/4]) == 0x0000000000080000)?
	          (0x0000000000005400):
	        (((unsigned long)(0x00000000000C0000 & dbc[i/4]) >>  9) | 0x0000000000004100))) |
		((8*i+8 >= dblen)? 0x00 :
		(((0x0000000000030000 & dbc[i/4]) == 0x0000000000020000)?
	          (0x0000000000000054):
	        (((unsigned long)(0x0000000000030000 & dbc[i/4]) >> 15) | 0x0000000000000041)));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
		       
      db[i+2] = ((8*i+23>= dblen)? 0x00 :
                (((0x0000C00000000000 & dbc[i/4]) == 0x0000800000000000)?
	          (0x5400000000000000):
	        (((unsigned long)(0x0000C00000000000 & dbc[i/4]) << 11) | 0x4100000000000000))) |
		((8*i+22>= dblen)? 0x00 :
		(((0x0000300000000000 & dbc[i/4]) == 0x0000200000000000)?
	          (0x0054000000000000):
	        (((unsigned long)(0x0000300000000000 & dbc[i/4]) <<  5) | 0x0041000000000000))) |
		((8*i+21>= dblen)? 0x00 :
		(((0x00000C0000000000 & dbc[i/4]) == 0x0000080000000000)?
	          (0x0000540000000000):
	        (((unsigned long)(0x00000C0000000000 & dbc[i/4]) >>  1) | 0x0000410000000000))) |
		((8*i+20>= dblen)? 0x00 :
		(((0x0000030000000000 & dbc[i/4]) == 0x0000020000000000)?
	          (0x0000005400000000):
	        (((unsigned long)(0x0000030000000000 & dbc[i/4]) >>  7) | 0x0000004100000000))) |
		((8*i+19>= dblen)? 0x00 :
		(((0x000000C000000000 & dbc[i/4]) == 0x0000008000000000)?
	          (0x0000000054000000):
	        (((unsigned long)(0x000000C000000000 & dbc[i/4]) >> 13) | 0x0000000041000000))) |
		((8*i+18>= dblen)? 0x00 :
		(((0x0000003000000000 & dbc[i/4]) == 0x0000002000000000)? 
	          (0x0000000000540000):
	        (((unsigned long)(0x0000003000000000 & dbc[i/4]) >> 19) | 0x0000000000410000))) |
		((8*i+17>= dblen)? 0x00 :
		(((0x0000000C00000000 & dbc[i/4]) == 0x0000000800000000)?
	          (0x0000000000005400):
	        (((unsigned long)(0x0000000C00000000 & dbc[i/4]) >> 25) | 0x0000000000004100))) |
		((8*i+16>= dblen)? 0x00 :
		(((0x0000000300000000 & dbc[i/4]) == 0x0000000200000000)?
	          (0x0000000000000054):
	        (((unsigned long)(0x0000000300000000 & dbc[i/4]) >> 31) | 0x0000000000000041)));

      if(i+4 > length) break; /* i.e. i+3 > length-1 ? */
		       
      db[i+3] = ((8*i+31>= dblen)? 0x00 :       /* out of chars? */
                (((0xC000000000000000 & dbc[i/4]) == 0x8000000000000000)? /* is it a T? */
	          (0x5400000000000000):
	        (((unsigned long)(0xC000000000000000 & dbc[i/4]) >>  5) | 0x4100000000000000))) |
		((8*i+30>= dblen)? 0x00 :
		(((0x3000000000000000 & dbc[i/4]) == 0x2000000000000000)? /* is it a T? */
	          (0x0054000000000000):
	        (((unsigned long)(0x3000000000000000 & dbc[i/4]) >> 11) | 0x0041000000000000))) |
		((8*i+29>= dblen)? 0x00 :
		(((0x0C00000000000000 & dbc[i/4]) == 0x0800000000000000)? /* is it a T? */
	          (0x0000540000000000):
	        (((unsigned long)(0x0C00000000000000 & dbc[i/4]) >> 17) | 0x0000410000000000))) |
		((8*i+28>= dblen)? 0x00 :
		(((0x0300000000000000 & dbc[i/4]) == 0x0200000000000000)? /* is it a T? */
	          (0x0000005400000000):
	        (((unsigned long)(0x0300000000000000 & dbc[i/4]) >> 23) | 0x0000004100000000))) |
		((8*i+27>= dblen)? 0x00 :
		(((0x00C0000000000000 & dbc[i/4]) == 0x0080000000000000)? /* is it a T? */
	          (0x0000000054000000):
	        (((unsigned long)(0x00C0000000000000 & dbc[i/4]) >> 29) | 0x0000000041000000))) |
		((8*i+26>= dblen)? 0x00 :
		(((0x0030000000000000 & dbc[i/4]) == 0x0020000000000000)? /* is it a T? */
	          (0x0000000000540000):
	        (((unsigned long)(0x0030000000000000 & dbc[i/4]) >> 35) | 0x0000000000410000))) |
		((8*i+25>= dblen)? 0x00 :
		(((0x000C000000000000 & dbc[i/4]) == 0x0008000000000000)? /* is it a T? */
	          (0x0000000000005400):
	        (((unsigned long)(0x000C000000000000 & dbc[i/4]) >> 41) | 0x0000000000004100))) |
		((8*i+24>= dblen)? 0x00 :
		(((0x0003000000000000 & dbc[i/4]) == 0x0002000000000000)? /* is it a T? */
	          (0x0000000000000054):
	        (((unsigned long)(0x0003000000000000 & dbc[i/4]) >> 47) | 0x0000000000000041)));
      break;
	
    case 4:
#pragma vdir nodep
      for(i=0; i<length-2; i+=2)
      {
        db[i]   = (bit4[(unsigned long)(0x00000000F0000000 & dbc[i/2]) >> 28] << 56) |
	          (bit4[(unsigned long)(0x000000000F000000 & dbc[i/2]) >> 24] << 48) |
	          (bit4[(unsigned long)(0x0000000000F00000 & dbc[i/2]) >> 20] << 40) |
	          (bit4[(unsigned long)(0x00000000000F0000 & dbc[i/2]) >> 16] << 32) |
	          (bit4[(unsigned long)(0x000000000000F000 & dbc[i/2]) >> 12] << 24) |
	          (bit4[(unsigned long)(0x0000000000000F00 & dbc[i/2]) >>  8] << 16) |
	          (bit4[(unsigned long)(0x00000000000000F0 & dbc[i/2]) >>  4] <<  8) |
	          (bit4[(unsigned long)(0x000000000000000F & dbc[i/2])]);
		  
	db[i+1] = (bit4[(unsigned long)(0xF000000000000000 & dbc[i/2]) >> 60] << 56) |
	          (bit4[(unsigned long)(0x0F00000000000000 & dbc[i/2]) >> 56] << 48) |
	          (bit4[(unsigned long)(0x00F0000000000000 & dbc[i/2]) >> 52] << 40) |
	          (bit4[(unsigned long)(0x000F000000000000 & dbc[i/2]) >> 48] << 32) |
	          (bit4[(unsigned long)(0x0000F00000000000 & dbc[i/2]) >> 44] << 24) |
	          (bit4[(unsigned long)(0x00000F0000000000 & dbc[i/2]) >> 40] << 16) |
	          (bit4[(unsigned long)(0x000000F000000000 & dbc[i/2]) >> 36] <<  8) |
	          (bit4[(unsigned long)(0x0000000F00000000 & dbc[i/2]) >> 32]);
      }
      db[i]   = ((8*i+7 >= dblen)?    0x00 :     /* out of chars? */
                (bit4[(unsigned long)(0x00000000F0000000 & dbc[i/2]) >> 28] << 56)) |
		((8*i+6 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000000000F000000 & dbc[i/2]) >> 24] << 48)) |
		((8*i+5 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000000000F00000 & dbc[i/2]) >> 20] << 40)) |
		((8*i+4 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00000000000F0000 & dbc[i/2]) >> 16] << 32)) |
		((8*i+3 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000000000000F000 & dbc[i/2]) >> 12] << 24)) |
		((8*i+2 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000000000000F00 & dbc[i/2]) >>  8] << 16)) |
		((8*i+1 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00000000000000F0 & dbc[i/2]) >>  4] <<  8)) |
		((8*i   >= dblen)?    0x00 :
	        (bit4[                0x000000000000000F & dbc[i/2]]));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
	
      db[i+1] = ((8*i+15>= dblen)?    0x00 :
                (bit4[(unsigned long)(0xF000000000000000 & dbc[i/2]) >> 60] << 56)) |
		((8*i+14>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0F00000000000000 & dbc[i/2]) >> 56] << 48)) |
		((8*i+13>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00F0000000000000 & dbc[i/2]) >> 52] << 40)) |
		((8*i+12>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000F000000000000 & dbc[i/2]) >> 48] << 32)) |
		((8*i+11>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000F00000000000 & dbc[i/2]) >> 44] << 24)) |
		((8*i+10>= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x00000F0000000000 & dbc[i/2]) >> 40] << 16)) |
		((8*i+9 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x000000F000000000 & dbc[i/2]) >> 36] <<  8)) |
		((8*i+8 >= dblen)?    0x00 :
	        (bit4[(unsigned long)(0x0000000F00000000 & dbc[i/2]) >> 32]));
      break;
	
    case 5:
      for(i=0; i<length-3; i+=3)
      {
        db[i]   = (((unsigned long)(0x00000000000001F0 & dbc[(2*i)/3]) >>  4) |
		   ((unsigned long)(0x0000000000003E00 & dbc[(2*i)/3]) >>  1) |
		   (               (0x000000000007C000 & dbc[(2*i)/3]) <<  2) |
		   (               (0x0000000000F80000 & dbc[(2*i)/3]) <<  5) |
	           (               (0x000000001F000000 & dbc[(2*i)/3]) <<  8) |
	           (               (0x00000003E0000000 & dbc[(2*i)/3]) << 11) |
	           (               (0x0000007C00000000 & dbc[(2*i)/3]) << 14) |
	           (               (0x00000F8000000000 & dbc[(2*i)/3]) << 17))| 
		                    0x4040404040404040;
		   
	db[i+1] = (((unsigned long)(0x0001F00000000000 & dbc[(2*i)/3])   >> 44)  |
	           ((unsigned long)(0x003E000000000000 & dbc[(2*i)/3])   >> 41)  |
	           ((unsigned long)(0x07C0000000000000 & dbc[(2*i)/3])   >> 38)  |
		   ((unsigned long)(0xF800000000000000 & dbc[(2*i)/3])   >> 35)  |
		   (               (0x00000000000001F0 & dbc[(2*i)/3+1]) << 28)  |
	           (               (0x0000000000003E00 & dbc[(2*i)/3+1]) << 31)  |
	           (               (0x000000000007C000 & dbc[(2*i)/3+1]) << 34)  |
	           (               (0x0000000000F80000 & dbc[(2*i)/3+1]) << 37)) | 
		                    0x4040404040404040;
	
	db[i+2] = (((unsigned long)(0x000000001F000000 & dbc[(2*i)/3+1]) >> 24)  |
		   ((unsigned long)(0x00000003E0000000 & dbc[(2*i)/3+1]) >> 21)  |
		   ((unsigned long)(0x0000007C00000000 & dbc[(2*i)/3+1]) >> 18)  |
		   ((unsigned long)(0x00000F8000000000 & dbc[(2*i)/3+1]) >> 15)  |
	           ((unsigned long)(0x0001F00000000000 & dbc[(2*i)/3+1]) >> 12)  |
	           ((unsigned long)(0x003E000000000000 & dbc[(2*i)/3+1]) >>  9)  |
	           ((unsigned long)(0x07C0000000000000 & dbc[(2*i)/3+1]) >>  6)  |
		   ((unsigned long)(0xF800000000000000 & dbc[(2*i)/3+1]) >>  3)) | 
		                    0x4040404040404040;
		  
      }
      db[i]   = ((8*i   >= dblen)? 0x00 :   /* out of chars? */
		(( (unsigned long)(0x00000000000001F0 & dbc[(2*i)/3]) >>  4) | 0x0000000000000040)) |
		((8*i+1 >= dblen)? 0x00 :
	        (( (unsigned long)(0x0000000000003E00 & dbc[(2*i)/3]) >>  1) | 0x0000000000004000)) |
		((8*i+2 >= dblen)? 0x00 :
		((                (0x000000000007C000 & dbc[(2*i)/3]) <<  2) | 0x0000000000400000)) |
		((8*i+3 >= dblen)? 0x00 :
		((                (0x0000000000F80000 & dbc[(2*i)/3]) <<  5) | 0x0000000040000000)) |
	        ((8*i+4 >= dblen)? 0x00 :
		((                (0x000000001F000000 & dbc[(2*i)/3]) <<  8) | 0x0000004000000000)) |
	        ((8*i+5 >= dblen)? 0x00 :
		((                (0x00000003E0000000 & dbc[(2*i)/3]) << 11) | 0x0000400000000000)) |
	        ((8*i+6 >= dblen)? 0x00 :
		((                (0x0000007C00000000 & dbc[(2*i)/3]) << 14) | 0x0040000000000000)) |
                ((8*i+5 >= dblen)? 0x00 :
                ((                (0x00000F8000000000 & dbc[(2*i)/3]) << 17) | 0x4000000000000000));

      if(i+2 > length) break; /* i.e. i+1 > length-1 ? */
		   
      db[i+1] = ((8*i+6 >= dblen)? 0x00 :
		(( (unsigned long)(0x0001F00000000000 & dbc[(2*i)/3])   >> 44) | 0x0000000000000040)) |
	        ((8*i+7 >= dblen)? 0x00 :
		(( (unsigned long)(0x003E000000000000 & dbc[(2*i)/3])   >> 41) | 0x0000000000004000)) |
	        ((8*i+8 >= dblen)? 0x00 :
		(( (unsigned long)(0x07C0000000000000 & dbc[(2*i)/3])   >> 38) | 0x0000000000400000)) |
		((8*i+9 >= dblen)? 0x00 :
		(( (unsigned long)(0xF800000000000000 & dbc[(2*i)/3])   >> 35) | 0x0000000040000000)) |
		((8*i+10>= dblen)? 0x00 :
		((                (0x00000000000001F0 & dbc[(2*i)/3+1]) << 28) | 0x0000004000000000)) |
	        ((8*i+11>= dblen)? 0x00 :
		((                (0x0000000000003E00 & dbc[(2*i)/3+1]) << 31) | 0x0000400000000000)) |
	        ((8*i+12>= dblen)? 0x00 :
		((                (0x000000000007C000 & dbc[(2*i)/3+1]) << 34) | 0x0040000000000000)) |
                ((8*i+13>= dblen)? 0x00 :
                ((                (0x0000000000F80000 & dbc[(2*i)/3+1]) << 37) | 0x4000000000000000));

      if(i+3 > length) break; /* i.e. i+2 > length-1 ? */
	
      db[i+2] = ((8*i+14>= dblen)? 0x00 :
		(( (unsigned long)(0x000000001F000000 & dbc[(2*i)/3+1]) >> 24) | 0x0000000000000040)) |
		((8*i+15>= dblen)? 0x00 :
		(( (unsigned long)(0x00000003E0000000 & dbc[(2*i)/3+1]) >> 21) | 0x0000000000004000)) |
		((8*i+16>= dblen)? 0x00 :
		(( (unsigned long)(0x0000007C00000000 & dbc[(2*i)/3+1]) >> 18) | 0x0000000000400000)) |
		((8*i+17>= dblen)? 0x00 :
		(( (unsigned long)(0x00000F8000000000 & dbc[(2*i)/3+1]) >> 15) | 0x0000000040000000)) |
	        ((8*i+18>= dblen)? 0x00 :
		(( (unsigned long)(0x0001F00000000000 & dbc[(2*i)/3+1]) >> 12) | 0x0000004000000000)) |
	        ((8*i+19>= dblen)? 0x00 :
		(( (unsigned long)(0x003E000000000000 & dbc[(2*i)/3+1]) >>  9) | 0x0000400000000000)) |
	        ((8*i+20>= dblen)? 0x00 :
		(( (unsigned long)(0x07C0000000000000 & dbc[(2*i)/3+1]) >>  6) | 0x0040000000000000)) |
                ((8*i+21>= dblen)? 0x00 :
                (( (unsigned long)(0xF800000000000000 & dbc[(2*i)/3+1]) >>  3) | 0x4000000000000000));
      break;
#endif /* little-endian */
    default:
      fprintf(stderr, "cb_compress: Invalid mode parameter %d, returning...\n", mode);
      return;
  }
#endif /* 64-bit */
}


/*
cb_uncompress(3B)                                         Last changed: 09-17-02

NAME
        cb_uncompress - Convert compressed nucleotide or amino acid data to ASCII

SYNOPSIS

        C/C++:

        #include <cbl.h>
        void cb_uncompress( long *dbc, long *db, long dblen, long mode);

        Fortran:

        use cb_comp
        call cb_uncompress( dbc, db, dblen, mode)


IMPLEMENTATION

        Cray SV1 series UNICOS systems

DESCRIPTION

        cb_uncompress reverses the data compression performed by the 
        cb_compress routine, converting compressed data into ASCII characters
        suitable for printing. The output array contains uppercase ASCII
        characters packed 8 per word. Because the compression for modes 2 and 4
        converts more than one letter to a particular code, the process of
        compression followed by uncompression may not result in a replica
        of the original sequence. 
        
        dbc     (input) packed codes. The number of bits/code and the amount
                of memory required depends on the mode value. In Fortran, 
                dbc should be an INTEGER(8) array.
                    
        db      (output) db contains ASCII text, packed 8 letters/word. Length 
                of db is (dblen+7)/8 (64-bit words).  The final word may be 
                filled with trailing nulls. The db array must be allocated
                before calling cb_uncompress. In Fortran, db should be an 
                INTEGER(8) array.
                    
        dblen   (input) Number of letters represented in db. In Fortran, 
                dblen should be an INTEGER(8) variable, constant, or
                expression.
            
        mode    (input) Allowed values are 2, 4, and 5. In Fortran, mode
                should be an INTEGER(8) variable, constant, or expression.
                    
                mode = 2:  Each 2-bit code sequence is converted to ASCII as 
                        follows:
               
                        00 -> A 
               
                        01 -> C 
               
                        10 -> T 
               
                        11 -> G 
               
               
                mode = 4: Each 4-bit code sequence is converted to ASCII as 
                        follows:
               
                        1000 -> A
                        0100 -> C
                        0010 -> G
                        0001 -> T
                        0111 -> B
                        1011 -> D
                        1101 -> H
                        0011 -> K
                        1100 -> M
                        1111 -> N
                        1010 -> R
                        0110 -> S
                        1110 -> V
                        1001 -> W
                        0101 -> Y
               
               
                mode = 5:  Each 5-bit code sequence represents an integer which is
                        converted to an ASCII letter as follows: 
               
                        {1,2,3,...,26} -> {A,B,C,...,Z} 
               
                        Packing in dbc is 12 letters in each 64-bit word, with the 
                        left 4 bits set to zero followed by 5*12 = 60 bits of 
                        data.

NOTES       
        cb_uncompress is single-threaded (i.e. not tasked) and may be called 
        from within a parallel region.  
        
        cb_uncompress replaces the contents of the bmm register.
               
SEE ALSO

        cb_compress(3B), INTRO_LIBCBL(3B)
*/
